
namespace test {
class Test {
  pub:
    Test() {}
}

fn [[test]] init_heap() i32 {
  let t = new Test();
  return true;
}

fn [[test]] init_stack() i32 {
  let t = new Test{};
  return true;
}

class ValueAccessTest {
  pub:
    let mut a: i32 = 0;
    ValueAccessTest() {}
}

fn [[test(expect = 0)]] value_access_stack() i32 {
  let t = new ValueAccessTest{};
  return t.a;
}

fn [[test(expect = 0)]] value_access_heap() i32 {
  let t = new ValueAccessTest();
  return t.a;
}

fn [[test]] value_access_stack_set() i32 {
  let t = new ValueAccessTest{};
  t.a = 1;
  return t.a;
}

fn [[test]] value_access_heap_set() i32 {
  let t = new ValueAccessTest();
  t.a = 1;
  return t.a;
}

class VirtualTest {
  pub:
    VirtualTest() {}
    virt fn test() i32 {
      return true;
    }
}

fn [[test(skip)]] virtual_stack() i32 {
  // TODO: what's going on here
  let t = new VirtualTest{};
  return t.test();
}

fn [[test]] virtual_heap() i32 {
  let t = new VirtualTest();
  return t.test();
}

class TypeInsideClassTest {
  pub:
    type x = VirtualTest;
    TypeInsideClassTest() {}
}

fn [[test]] type_inside_class() i32 {
  let t: TypeInsideClassTest::x = new VirtualTest{};
  return true;
}

class ClassGenericsTest<T> {
  pub:
    ClassGenericsTest(x: T) {}
}

fn [[test]] class_generics() i32 {
  let t = new ClassGenericsTest<i32>(1);
  return true;
}

class ClassDefaultGenericsTest<T = i32> {
  pub:
    ClassDefaultGenericsTest(x: T) {}
}

fn [[test]] class_default_generics() i32 {
  let t = new ClassDefaultGenericsTest<>(1);
  return true;
}

class GenericAccessTest<T> {
  pub:
    let mut a: T = 0;
    GenericAccessTest() {}
}

fn [[test(expect = 0)]] generic_access_stack() i32 {
  let t = new GenericAccessTest<i32>{};
  return t.a;
}

}
