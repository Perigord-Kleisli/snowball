
namespace test {
class Test {
  pub:
    Test() {}
    let succ: bool = true;
}

fn [[test]] init_heap() i32 {
  let t = new Test();
  return t.succ;
}

class ValueAccessTest {
  pub:
    let mut a: i32 = 0;
    ValueAccessTest() {}
}

fn [[test(expect = 0)]] value_access_heap() i32 {
  let t = new ValueAccessTest();
  return t.a;
}

fn [[test]] value_access_set() i32 {
  let t = new ValueAccessTest();
  t.a = 1;
  return t.a;
}

class VirtualTest {
  pub:
    VirtualTest() {}
    virt fn test() i32 {
      return true;
    }
  priv:
    let a: i32 = 0;
    let b: i32 = 2;
}

fn [[test]] virtual_stack() i32 {
  // TODO: what's going on here
  let t = new VirtualTest();
  return t.test();
}

fn [[test]] virtual_heap() i32 {
  let t = &new VirtualTest();
  return t.test();
}

class TypeInsideClassTest {
  pub:
    type x = VirtualTest;
    TypeInsideClassTest() {}
}

fn [[test]] type_inside_class() i32 {
  let t: TypeInsideClassTest::x = new VirtualTest();
  return true;
}

class ClassGenericsTest<T> {
  pub:
    ClassGenericsTest(x: T) {}
}

fn [[test]] class_generics() i32 {
  let t = new ClassGenericsTest<i32>(1);
  return true;
}

class ClassDefaultGenericsTest<T = i32> {
  pub:
    ClassDefaultGenericsTest(x: T) {}
}

fn [[test]] class_default_generics() i32 {
  let t = new ClassDefaultGenericsTest<>(1);
  return true;
}

class GenericAccessTest<T> {
  pub:
    let mut a: T = 0;
    GenericAccessTest() {}
}

fn [[test(expect = 0)]] generic_access() i32 {
  let t = new GenericAccessTest<i32>();
  return t.a;
}

class InheritedOverrideVirtualTest: VirtualTest {
  pub:
    InheritedOverrideVirtualTest() : super() {}
    virt fn test() i32 {
      return false;
    }
}

fn [[test(expect = 0)]] inherited_override_virtual() i32 {
  let t = new InheritedOverrideVirtualTest();
  return t.test();
}

class InheritanceVirtualTest: VirtualTest {
  pub:
    InheritanceVirtualTest() : super() {}
}

fn [[test]] inheritance_virtual() i32 {
  let t = new InheritanceVirtualTest();
  return t.test();
}

}
