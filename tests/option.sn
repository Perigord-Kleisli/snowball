import Core::Optional;
import Core::CLib;
import Core::System;

namespace tests {

func [[test(expect = 1)]] empty_from_func() i32 {
    let x = Optional::None<?i32>();
    //CLib::printf("x: %i", Optional::None<?i32>().empty()) 
    return x.empty();
}

func [[test]] empty_from_class() i32 {
    let x = new Optional::Option<i32>();
    return x.empty();
}

func [[test]] with_value_from_func() i32 {
    let x = Optional::Some(42);
    return !x.empty();
}

func [[test]] with_value_from_class() i32 {
    let x = new Optional::Option<i32>(42);
    return !x.empty();
}

func [[test(expect = 42)]] test_value_from_func() i32 {
    let x = Optional::Some(42);
    let a = x.val();
    return x.val();
}

func [[test(expect = 24)]] pointer_value() i32 {
    let x = new Optional::Option<&i32>(&24);
    return *x.val();
}

func [[test(expect = 42)]] value_default() i32 {
    let x = new Optional::Option<i32>();
    return x.value_or(42);
}

func [[test]] empty_value_class() i32 {
    let x = new Optional::Option<String>();
    return x.empty();
}

func [[test(expect = 5)]] value_class() i32 {
    let s = "hello";
    let x = new Optional::Option<String>(s);
    return x.val().size();
}

func [[test]] access_empty() i32 {
    let x = new Optional::Option<i32>();
    try {
        x.val();
    } catch (_: Optional::BadOptionAccess) {
        return true;
    }
    return 0;
}

}