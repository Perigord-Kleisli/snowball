import std::c_bindings;
import std::ptr;

@use_macro(assert)
import std::asserts;

type Option<T> = opt::Option<T>;

/**
 * @brief Returns the error message for the last error that occurred.
 * @param code The error code to get the message for.
 * @return The error message for the last error that occurred.
 */
public func posix_get_error_msg(code: i32) String {
  unsafe {
    let err = c_bindings::strerror(code);
    return String::from_cstr(err);
  }
}

import std::io;

/**
 * The `Args` class serves as a versatile container for command-line arguments 
 * within the Snowball programming environment. Designed to encapsulate and 
 * manage command-line inputs, this class employs a vector to store individual arguments, 
 * with each argument represented as a Snowball String. The class implements two crucial 
 * traits: `ToString`, facilitating the conversion of the entire set of arguments into a 
 * unified string representation, and `Iterable<String>`, enabling seamless iteration over 
 * the individual arguments. Constructed by providing the number of arguments (`argc`) and 
 * a pointer to an array of null-terminated strings (`argv`), the class efficiently converts 
 * C-style strings into Snowball Strings.
 * 
 * The constructor populates the internal vector (`args`) with the converted arguments, 
 * establishing a convenient abstraction for further manipulation and analysis of 
 * the command-line inputs.
 * 
 * The `Args` class is equipped with a range of accessor methods, including 
 * `get` for retrieving an argument at a specified index, `size` for determining 
 * the total number of arguments, and `to_string` for obtaining a string 
 * representation of the entire argument set. 
 * 
 * Additionally, the class implements the `Iterable` trait, 
 * allowing users to iterate over individual arguments using a simple `for` loop. 
 * This functionality simplifies the process of handling and processing
 * command-line inputs within Snowball programs. With an iterator mechanism provided 
 * through the `next` and `reset` methods, users can easily traverse through the arguments, 
 * making the class an integral component for scenarios requiring flexible interaction 
 * with command-line data.
 *
 * It is used instead of a `Vector<String>` because it will prevent
 * the user from mutating the arguments. This is important because
 * the arguments are passed to the program by the operating system
 * and they should not be mutated.
 * 
 * ```
 * let args = env::argv();
 * for arg in args {
 *  io::println(arg);
 * }
 * ```
 */
public class Args implements ToString, Iterable<String> {
  /**
   * Vector to store command-line arguments.
   * Each argument is represented as a Snowball String.
   */
  let mut args: Vector<String> = new Vector<String>();
 public:
  /**
   * Constructs an `Args` object based on the provided command-line arguments.
   * @param argc The number of command-line arguments.
   * @param argv Pointer to an array of pointers to null-terminated strings representing the arguments.
   * @remark This constructor converts C-style strings to Snowball Strings and populates the `args` vector.
   * @important This constructor is called by the Snowball runtime and should not be called by the user.
   */
  Args(argc: i32, argv: *const *const u8) {
    for let i = 0; i < argc; i = i + 1 {
      unsafe {
        self.args.push(String::from_cstr(argv[i]));
      }
    }
  }
  /**
   * Gets the argument at the specified index.
   * @param index The index of the argument to retrieve.
   * @return The argument at the specified index.
   */
  @inline func get(index: usize) String {
    return self.args[index];
  }
  /**
   * Gets the number of arguments in the container.
   * @return The number of arguments.
   */
  @inline func size() usize {
    return self.args.size();
  }
  /**
   * Converts the arguments to a string representation.
   * @return A string representation of the arguments.
   */
  @inline func to_string() String {
    return self.args.to_string();
  }
  /**
   * Implements the `next` method of the `Iterable` trait for iterating over arguments.
   * @return An iterator for the arguments.
   */
  virtual mut func next() Iter<String> { return self.args.next(); }
  /**
   * Resets the iterator to the beginning of the arguments.
   */
  @inline
  virtual mut func reset() { self.args.reset(); }
}
/**
 * Global variable to hold the command-line arguments.
 */
let mut _g_args = ptr::null_ptr<?Args>();
/**
 * Sets the command-line arguments for the Snowball environment.
 * @param argc The number of command-line arguments.
 * @param argv Pointer to an array of pointers to null-terminated strings representing the arguments.
 */
@inline
@export(name = "sn.env.set_argv")
private func snowball_set_argv(argc: i32, argv: *const *const u8) {
  let arg: *const Args = new Args(argc, argv);
  _g_args = ptr::Allocator<?Args>::alloc(1).ptr();
  ptr::copy_nonoverlapping(arg, _g_args, sizeof!(:Args));
}
/**
 * @brief Returns the arguments passed to the program.
 * @return The arguments passed to the program.
 * @note This function will panic if it is called before main().
 *  meaning that it can't be used in global variables.
 */
@inline
public func argv() Args {
  assert!(!_g_args.is_null(), "argv() was called before main()");
  unsafe {
    return *_g_args;
  }
}