use Core::CLib;
use Core::Ptr;

/**
 * @brief The error thrown when an `Option` is empty.
 */
pub class BadOptionAccess: Exception
  {}
/**
 * A type that represents either a value or nothing at all.
 *
 * The Option type is used in many places because it encodes the very common
 * scenario in which a value could be something or it could be nothing.
 *
 * For example, the `find` method on containers like `Array` and `Hash` returns
 * an `Option` because the element may or may not exist in the container.
 *
 * The `Option` type is also used in the return type of functions that are not
 * guaranteed to return a value, like `Array::pop` or `Hash::delete`.
 */
pub class Option<_StoreType: Core::Sized> {
    /**
     * The value stored in the `Option`.
     */
    let _value: *const _StoreType = Ptr::null_ptr<?_StoreType>();
    /**
     * Whether the `Option` is engaged.
     */
    let _engage: bool = false;
  pub:
    /**
     * Creates a new empty `Option`.
     */
    Option() {}
    /**
     * Creates a new `Option` with the given value.
     *
     * @param value The value to store in the `Option`.
     */
    Option(value: _StoreType) : _value(value), 
      _engage(true) {}
    /**
     * @brief Returns the value stored in the `Option`.
     */
    fn [[inline]] val() &mut _StoreType
    {
      self.assert_not_empty();
      unsafe {
        let x = *self._value;
      }
      unsafe { return self._value.as_ref(); }
    }
    /**
     * @brief Returns whether the `Option` is empty.
     */
    fn [[inline]] empty() bool 
    {
      return !self._engage;
    }
    /**
     * @brief Whether the `Option` is engaged.
     */
    fn [[inline]] has_value() bool
      { return self._engage; }
    /**
     * @return The value stored in the `Option` or the
     *        given default value if the `Option` is empty.
     */
    fn [[inline]] value_or(default_value: &_StoreType) &mut _StoreType
    {
      if (self.empty()) {
        return default_value;
      }
      unsafe { return self._value.as_ref(); }
    }
  priv:
    /**
     * @brief Throws an error if the `Option` is empty.
     */
    fn [[inline]] assert_not_empty()
    {
      if (self.empty()) {
        raise new BadOptionAccess("Attempted to access empty Option");
      }
    }
}
/**
 * @brief Creates a new `Option` with the given value.
 * @param value The value to store in the `Option`.
 */
pub fn [[inline]] Some<_StoreType>(value: _StoreType) Option<_StoreType>
  { return new Option<_StoreType>{value}; }
/**
 * @brief Creates a new empty `Option`.
 */
pub fn [[inline]] None<_StoreType>() Option<_StoreType>
  { return new Option<_StoreType>{}; }
  