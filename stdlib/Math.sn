use Core::CLib;
use Core::Ptr;
/**
 * It performs the square root of a given floating-point number.
 *
 * @param x The floating-point number to perform the square root of.
 * @return The square root of the given number.
 */
pub extern fn "llvm.sqrt.f64" as sqrt(f64) f64;
/**
 * It performs the cube root of a given floating-point number.
 *
 * @param x The floating-point number to perform the cube root of.
 * @return The cube root of the given number.
 */
pub extern fn "llvm.cbrt.f64" as cbrt(f64) f64;
/**
 * It returns the minimum of two given unknown numbers.
 *
 * @param x The first number.
 * @param y The second number.
 * @return The minimum of the two given numbers.
 */
pub fn min<T: Core::IsNumeric>(x: T, y: T) T 
    { if x < y { x } else { y } } // TODO: use ternary operator once implemented

/**
 * The constant value of pi, accurate to 35 decimal places.
 * @example PI // returns 3.141592653589793238462643383279502884197
 */
pub const PI: f32 = 3.141592653589793238462643383279502884197;
/**
 * @brief The natural logarithm of pi.
 */
pub const logpi: f32 = 1.144729885849400174143427351353058711647;
/**
 * @brief The square root of pi.
 */
pub const sqrtpi: f32 = 1.772453850905516027298167483341145182798;
/**
 * @brief Positive infinity constant.
 */
pub const inf: f64 = 1 as f64 / 0 as f64;
/**
 * @brief NaN constant.
 * 
 * @note This needs to be defined using `strtod` as there is no built-in NaN value in C++.
 * @todo Implement `nanf` and `nanl` functions to define `nanf` and `nanl` constants respectively.
 */
pub const nan: f64 = 0 as f64 / 0 as f64;
/**
 * @brief Check if a floating-point number is NaN (not-a-number).
 * 
 * @param x The number to check.
 * @return True if `x` is NaN, false otherwise.
 */
pub extern fn "isnan" as is_nan(f64) bool;
/**
 * @brief Check if a floating-point number is infinite.
 * 
 * @param x The number to check.
 * @return True if `x` is infinite, false otherwise.
 */
pub extern fn "isinf" as is_inf(f64) bool;

