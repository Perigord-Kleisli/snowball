use Core::CLib;

namespace Core {

/**
 * @namespace UA
 * @brief The namespace containing the universal array library.
 *
 * The UA namespace contains the universal array library. It provides
 * various operations and functionalities for working with universal
 * arrays of elements. It supports common universal array manipulation
 * operations such as element insertion, element removal, element access,
 * and more.
 *
 * @note The UA namespace is designed to be efficient and memory-safe.
 *       It automatically manages the memory allocation and deallocation
 *       required for storing and manipulating universal arrays.
 */
pub namespace UA {
/**
 * @class UniversalArray
 * @brief A class representing a universal array of elements.
 *
 * The UniversalArray class provides various operations and functionalities
 * for working with universal arrays of elements. It supports common
 * UniversalArray manipulation operations such as element insertion,
 * element removal, element access, and more.
 *
 * @note The UniversalArray class is designed to be efficient and memory-safe.
 *       It automatically manages the memory allocation and deallocation
 *       required for storing and manipulating universal arrays.
 */
pub struct UniversalArray 
  { pub let items: cobj&; };
/**
 * @brief Allocates a universal array of elements.
 * @param[in] size The size of the universal array to allocate.
 * @return The allocated universal array.
 */
pub extern fn "sn.ua.alloc" as __ua_alloc(i32) UniversalArray&;
/**
 * @brief Resizes a universal array of elements.
 * @param[in] array The universal array to resize.
 * @param[in] size The new size of the universal array.
 * @return The resized universal array.
 */
pub extern fn "sn.ua.resize" as __ua_resize(UniversalArray&, i32) UniversalArray&;
/**
 * @brief Sets an element in a universal array.
 * @param[in] array The universal array to set the element in.
 * @param[in] index The index of the element to set.
 * @param[in] item The element to set.
 */
pub extern fn "sn.ua.set" as __ua_set(UniversalArray&, i32, cobj);

/**
 * @brief Gets an element from a universal array.
 * @param[in] array The universal array to get the element from.
 * @param[in] index The index of the element to get.
 * @return The element at the specified index.
 */
pub extern fn "sn.ua.get" as __ua_get(UniversalArray&, i32) cobj;

} /* namespace UA */;

/**
 * @namespace __internal
 * @brief The namespace containing internal functions.
 *
 * The __internal namespace contains internal functions. It provides
 * various operations and functionalities for working with internal
 * functions. It supports common internal function manipulation
 * operations such as exception throwing, exception catching,
 * exception handling, and more.
 *
 * @note The __internal namespace is designed to be efficient and memory-safe.
 *       It automatically manages the memory allocation and deallocation
 *       required for storing and manipulating internal functions.
 */
namespace __internal {

fn [[export(name = "sn.test.try"), cfg(test), no_inline]] __snowball_test()
{

}

} /* namespace __internal */;

/**
 * @class Exception
 * @brief A class representing an exception.
 *
 * The Exception class provides various operations and functionalities
 * for working with exceptions. It supports common Exception
 * manipulation operations such as exception throwing, exception
 * catching, exception handling, and more.
 */
pub class Exception {
  pub:
    /**
     * @brief Exception constructor.
     * @param[in] m The message of the exception.
     */ 
    Exception(m: char&) : msg(m) 
      { }
    /**
      * @brief Exception constructor from a string.
      * @param[in] m The message of the exception.
      */
    Exception(m: String) : msg(m.c_str()) 
      { }
    /**
     * @brief Returns the message of the exception.
     * @return The message of the exception.
     */
    fn what() char& 
      { return self.msg; }
  priv:
    /** The message of the exception. */
    let msg: char&;
}

/**
 * @class IndexError
 * @brief A class representing an index error.
 *
 * The IndexError class provides various operations and functionalities
 * for working with index errors. It supports common IndexError
 * manipulation operations such as exception throwing, exception
 * catching, exception handling, and more.
 */
pub class IndexError: Exception 
  { }

pub class Iterable<_IteratorType: Core::Sized> {
  pub:
    Iterable() {}
}

/**
 * @class Vector
 * @brief A class representing a vector of elements.
 *
 * The Vector class provides various operations and functionalities
 * for working with vectors of elements. It supports common Vector
 * manipulation operations such as element insertion, element removal,
 * element access, and more.
 *
 * @note The Vector class is designed to be efficient and memory-safe.
 *       It automatically manages the memory allocation and deallocation
 *       required for storing and manipulating vectors.
 */
pub class Vector<_StoreType: Core::Sized>: Iterable<_StoreType&> {
  pub:
    /**
     * @brief Default constructor.
     * Constructs an empty vector.
     */
    Vector() : super(), 
      buffer(UA::__ua_alloc(self.capacity)) {}
    /**
     * @brief It pushes an element to the back of the vector.
     * @param[in] value The element to push to the back of the vector.
     */
    fn [[internal_linkage]] push(value: _StoreType&) mut
    { 
      if self.length + 1 >= self.capacity 
      {
        self.resize(self.capacity + 10);
      }
      UA::__ua_set(self.buffer, self.length, value as cobj);
      self.length = self.length + 1;
    }
    /**
     * @return The size of the vector.
     */
    fn [[internal_linkage, inline]] size() i32 { return self.length; }
    /**
     * @brief Resizes the vector.
     * @param[in] capacity The new capacity of the vector.
     */
    fn [[internal_linkage]] resize(capacity: i32) mut
    { 
      self.capacity = capacity;
      self.buffer = UA::__ua_resize(self.buffer, self.capacity); 
    }
    /**
     * @brief Returns the element at the specified index.
     * @param[in] index The index of the element to return.
     * @return The element at the specified index.
     */
    fn [[internal_linkage]] at(index: i32) _StoreType&
    {
      if index < 0 || index >= self.length 
      {
        raise new IndexError("Index out of bounds.");
      }
      return UA::__ua_get(self.buffer, index) as _StoreType&;
    }
    /**
     * @brief Returns the data of the vector.
     * @return The data of the vector.
     */
    fn [[internal_linkage, inline]] data() _StoreType& 
      { return (*self.buffer.items) as _StoreType& }
    /**
     * @brief A wrapper over the at() method.
     * @param[in] index The index of the element to return.
     * @return The element at the specified index.
     * @see Vector<_StoreType>::at()
     */
    operator [[internal_linkage, inline]] [](index: i32) _StoreType& 
      { return self.at(index); }

  priv:
    /** The capacity of the vector. */
    let mut capacity: i32 = 10;
    /** The size of the vector. */
    let mut length: i32 = 0;
    /** The buffer containing the vector. */
    let buffer: UA::UniversalArray&;
}

/**
 * @class StringView
 * @brief A class representing a string of characters.
 *
 * The StringView class provides various operations and functionalities
 * for working with strings of characters. It supports common StringView
 * manipulation operations such as concatenation, substring extraction,
 * length calculation, and more.
 *
 * @note The StringView class is designed to be efficient and memory-safe.
 *       It automatically manages the memory allocation and deallocation
 *       required for storing and manipulating strings.
 */
pub class StringView<_CharType: Core::Sized = char>: Iterable<_CharType> {
  pub:
    /**
     * @brief Default constructor.
     * Constructs an empty string.
     */
    StringView() : super() 
      {}
    /**
      * @brief Constructs a string from a vector of characters.
      * @param[in] buffer The vector of characters to construct the string from.
      */
    StringView(buffer: _CharType&) : 
      super(), buffer(buffer), length(CLib::c_string::strlen(buffer))
      { self.capacity = self.length + 10; }
    /**
     * @brief Constructs a string from another string.
     * @param[in] other The string to construct the string from.
     */
    StringView(other: StringView<_CharType>&) : 
      super(), buffer(other.buffer), length(other.length), 
      capacity(other.capacity) { }
    /**
      * @return The size of the string.
      */
    fn [[internal_linkage, inline]] size() i32 
      { return self.length; }
    /**
      * @return The buffer containing the string.
      */
    fn [[internal_linkage, inline]] c_str() _CharType&
      { return self.buffer; }
  priv:
    /** The capacity of the string. */
    let mut capacity: i32 = 10;
    /** The size of the string. */
    let mut length: i32 = 0;
    /** The buffer containing the string. */
    let buffer: _CharType& = "";

  priv:
    /**
     * @brief Creates a new string from a number.
     * @param[in] num The number to create the string from.
     * @param[in] format The format of the number.
     * @return The created string.
     */
    static fn [[internal_linkage, inline]] fromNumber<T>(num: T, format: char& = "%ld")
      StringView<_CharType> 
    { 
      let buffer: _CharType& = 
        CLib::__internal::alloca_and_snprintf(10, format, num);
      return new StringView<_CharType>{buffer}; 
    }

  // Static exports
  pub:
    /**
     * @brief Constructs a string from a long integer. 
     * @param[in] num The integer to construct the string from.
     */
    static fn [[internal_linkage, inline]] from(num: i64)
      StringView<_CharType> 
    { return Self::fromNumber(num, "%ld"); }
    /**
     * @brief Constructs a string from an integer. 
     * @param[in] num The integer to construct the string from.
     */
    static fn [[internal_linkage, inline]] from(num: i32)
      StringView<_CharType> 
    { return Self::fromNumber(num, "%i"); }

    /**
      * @brief Constructs a string from a vector of characters.
      * @param[in] buffer The vector of characters to construct the string from.
      */
    static fn [[internal_linkage, inline]] from<T>(buffer: T)
      StringView<char> { return new StringView<char>{buffer}; }
}

} // namespace Core

// Type exports
type StringView<T = char> = Core::StringView<T>;
type Vector<T> = Core::Vector<T>;
type Exception = Core::Exception;
type IndexError = Core::IndexError;
type String = StringView<>;
// TODO (implement wchar): using WideString as StringView<wchar&>
