use Core::CLib;

namespace Core {

/**
 * @namespace UA
 * @brief The namespace containing the universal array library.
 *
 * The UA namespace contains the universal array library. It provides
 * various operations and functionalities for working with universal
 * arrays of elements. It supports common universal array manipulation
 * operations such as element insertion, element removal, element access,
 * and more.
 *
 * @note The UA namespace is designed to be efficient and memory-safe.
 *       It automatically manages the memory allocation and deallocation
 *       required for storing and manipulating universal arrays.
 */
pub namespace UA {
/**
 * @class UniversalArray
 * @brief A class representing a universal array of elements.
 *
 * The UniversalArray class provides various operations and functionalities
 * for working with universal arrays of elements. It supports common
 * UniversalArray manipulation operations such as element insertion,
 * element removal, element access, and more.
 *
 * @note The UniversalArray class is designed to be efficient and memory-safe.
 *       It automatically manages the memory allocation and deallocation
 *       required for storing and manipulating universal arrays.
 */
pub struct UniversalArray 
  { pub let items: cobj&; };
/**
 * @brief Allocates a universal array of elements.
 * @param[in] size The size of the universal array to allocate.
 * @return The allocated universal array.
 */
pub extern fn [[no_inline]] "sn.ua.alloc" as __ua_alloc(i32) UniversalArray&;
/**
 * @brief Resizes a universal array of elements.
 * @param[in] array The universal array to resize.
 * @param[in] size The new size of the universal array.
 * @return The resized universal array.
 */
pub extern fn "sn.ua.resize" as __ua_resize(UniversalArray&, i32) UniversalArray&;
/**
 * @brief Sets an element in a universal array.
 * @param[in] array The universal array to set the element in.
 * @param[in] index The index of the element to set.
 * @param[in] item The element to set.
 */
pub extern fn "sn.ua.set" as __ua_set(UniversalArray&, i32, cobj);

/**
 * @brief Gets an element from a universal array.
 * @param[in] array The universal array to get the element from.
 * @param[in] index The index of the element to get.
 * @return The element at the specified index.
 */
pub extern fn "sn.ua.get" as __ua_get(UniversalArray&, i32) cobj;

} /* namespace UA */;

/**
 * @namespace __internal
 * @brief The namespace containing internal functions.
 *
 * The __internal namespace contains internal functions. It provides
 * various operations and functionalities for working with internal
 * functions. It supports common internal function manipulation
 * operations such as exception throwing, exception catching,
 * exception handling, and more.
 *
 * @note The __internal namespace is designed to be efficient and memory-safe.
 *       It automatically manages the memory allocation and deallocation
 *       required for storing and manipulating internal functions.
 */
namespace __internal {

fn [[
  export(name = "sn.test.try"), 
  cfg(test), 
  no_inline
]] snowball_test(
  func: fn () => i32,
  name: char&,
  skip: bool = false,
  expect: i32 = 1
) i32 {
  let mut tty = "should pass";
  if expect != 1 {
    // TODO:
    tty = CLib::__internal::alloca_and_snprintf(25, "expecting \e[1m`%i`\e[0m", expect);
  }
  CLib::printf(" Testing \e[1m%s\e[0m [%s] ... ", name, tty);
  // TODO: Add support for exceptions
  if !skip {
    try {
      let result = func();
      if result == expect {
        CLib::printf("\e[1;32mnice!\e[0m\n");
      } else {
        CLib::printf("\e[1;31merror \n");
        CLib::printf("\n UNEXPECTED RESULT:\n");
        CLib::printf("   --> Expected a success return value (%i) but got `%i`\n", expect, result);
        CLib::printf("\e[0m\n");
        return false;
      }
    } catch (e: Exception&) {
      CLib::printf("\n UNEXPECTED EXCEPTION:\n");
      CLib::printf("   --> %s\n", e.what());
      CLib::printf("\e[0m\n");
      return false;
    }
  } else {
    CLib::printf("\e[1;33mwip\e[0m\n");
  }
  return true;
}

} /* namespace __internal */;

/**
 * @class Exception
 * @brief A class representing an exception.
 *
 * The Exception class provides various operations and functionalities
 * for working with exceptions. It supports common Exception
 * manipulation operations such as exception throwing, exception
 * catching, exception handling, and more.
 */
pub class Exception {
  pub:
    /**
     * @brief Exception constructor.
     * @param[in] m The message of the exception.
     */ 
    Exception(m: char&) : msg(m) 
      { }
    /**
      * @brief Exception constructor from a string.
      * @param[in] m The message of the exception.
      */
    Exception(m: String) : msg(m.c_str()) 
      { }
    /**
     * @brief Returns the message of the exception.
     * @return The message of the exception.
     */
    fn what() char& 
      { return self.msg; }
  priv:
    /** The message of the exception. */
    let msg: char&;
}
/**
 * @class IndexError
 * @brief A class representing an index error.
 *
 * The IndexError class provides various operations and functionalities
 * for working with index errors. It supports common IndexError
 * manipulation operations such as exception throwing, exception
 * catching, exception handling, and more.
 */
pub class IndexError: Exception 
  { }
/**
 * @class Iterable
 * @brief A class representing an iterable.
 *
 * The Iterable class provides various operations and functionalities
 * for working with iterables. It supports common Iterable
 * manipulation operations such as iteration, element access, and more.
 */
pub class Iterable<_IteratorType: Core::Sized> {
  pub:
    Iterable() {}
}
/**
 * @class Iter
 * @brief A class representing an iterator.
 *
 * The Iter can be considered as the reverse of the Iterable class.
 * It provides various operations and functionalities for working
 * with iterators. It supports common Iter manipulation operations
 * such as iteration, element access, and more.
 */
pub class Iter<_IteratorType: Core::Sized> {
    /// @brief if the iterator is valid
    let valid: bool = false;
  pub:
    /**
     * @brief Iter constructor.
     * @note It creates an invalid iterator.
     */
    Iter() {}
}


/**
 * @class Vector
 * @brief A class representing a vector of elements.
 *
 * The Vector class provides various operations and functionalities
 * for working with vectors of elements. It supports common Vector
 * manipulation operations such as element insertion, element removal,
 * element access, and more.
 *
 * @note The Vector class is designed to be efficient and memory-safe.
 *       It automatically manages the memory allocation and deallocation
 *       required for storing and manipulating vectors.
 */
pub class Vector<_StoreType: Core::Sized>: Iterable<_StoreType> {
  pub:
    /**
     * @brief Default constructor.
     * Constructs an empty vector.
     */
    Vector() : super(), 
      buffer(UA::__ua_alloc(self.capacity)) {}
    /**
     * @brief It pushes an element to the back of the vector.
     * @param[in] value The element to push to the back of the vector.
     */
    fn [[internal_linkage]] push(value: _StoreType) mut
    { 
      if self.length + 1 >= self.capacity 
      {
        self.resize(self.capacity + 10);
      }
      UA::__ua_set(self.buffer, self.length, value as cobj);
      self.length = self.length + 1;
    }
    /**
     * @return The size of the vector.
     */
    fn [[internal_linkage, inline]] size() i32 { return self.length; }
    /**
     * @brief Resizes the vector.
     * @param[in] capacity The new capacity of the vector.
     */
    fn [[internal_linkage]] resize(capacity: i32) mut
    { 
      self.capacity = capacity;
      self.buffer = UA::__ua_resize(self.buffer, self.capacity); 
    }
    /**
     * @brief Returns the element at the specified index.
     * @param[in] index The index of the element to return.
     * @return The element at the specified index.
     */
    fn [[internal_linkage]] at(index: i32) _StoreType
    {
      if index < 0 || index >= self.length 
      {
        raise new IndexError("Index out of bounds.");
      }
      return UA::__ua_get(self.buffer, index) as _StoreType;
    }
    /**
     * @brief Returns the data of the vector.
     * @return The data of the vector.
     */
    fn [[internal_linkage, inline]] data() _StoreType&
      { return (*self.buffer.items) as _StoreType&; }
    /**
     * @brief A wrapper over the at() method.
     * @param[in] index The index of the element to return.
     * @return The element at the specified index.
     * @see Vector<_StoreType>::at()
     */
    operator [[internal_linkage, inline]] [](index: i32) _StoreType
      { return self.at(index); }
    /**
     * @brief It inserts an element at the specified index.
     * @param[in] index The index to insert the element at.
     * @param[in] value The element to insert.
     */
    fn [[internal_linkage]] insert(index: i32, value: _StoreType) mut
    {
      if index >= self.length 
      {
        self.push(value);
        return;
      }
      let cur = UA::__ua_get(self.buffer, index) as _StoreType;
      UA::__ua_set(self.buffer, index, value as cobj);
      self.insert(index + 1, cur);
    }
    /**
     * @brief It returns a string representation of the vector.
     * @return A string representation of the vector.
     */
    fn [[internal_linkage]] to_string<>() String {
      // TODO: Implement this
      //return x.to_str()
    }

  priv:
    /** The capacity of the vector. */
    let mut capacity: i32 = 10;
    /** The size of the vector. */
    let mut length: i32 = 0;
    /** The buffer containing the vector. */
    let mut buffer: UA::UniversalArray&;
}

/**
 * @class StringView
 * @brief A class representing a string of characters.
 *
 * The StringView class provides various operations and functionalities
 * for working with strings of characters. It supports common StringView
 * manipulation operations such as concatenation, substring extraction,
 * length calculation, and more.
 *
 * @note The StringView class is designed to be efficient and memory-safe.
 *       It automatically manages the memory allocation and deallocation
 *       required for storing and manipulating strings.
 */
pub class StringView<_CharType: Core::Sized = char>: Iterable<_CharType> {
  pub:
    type StringType = _CharType&;

    /**
     * @brief Default constructor.
     * Constructs an empty string.
     */
    StringView() : super() 
      {}
    /**
      * @brief Constructs a string from a vector of characters.
      * @param[in] buffer The vector of characters to construct the string from.
      */
    StringView(buffer: StringType) : 
      super(), buffer(buffer), length(CLib::c_string::strlen(buffer))
      { self.capacity = self.length + 10; }
    /**
     * @brief Constructs a string from another string.
     * @param[in] other The string to construct the string from.
     */
    StringView(other: StringView<_CharType>&) : 
      super(), buffer(other.buffer), length(other.length), 
      capacity(other.capacity) { }
    /**
      * @return The size of the string.
      */
    fn [[internal_linkage, inline]] size() i32 
      { return self.length; }
    /**
      * @return The buffer containing the string.
      */
    fn [[internal_linkage, inline]] c_str() StringType
      { return self.buffer; }
    /**
     * @brief It compares the string with another string.
     * @param[in] other The string to compare the string with.
     * @return The result of the comparison.
     */
    operator [[internal_linkage, inline]] ==(other: StringView<_CharType>) bool
    {
      if self.length != other.length 
      {
        return false;
      }
      // TODO:
      //for i in 0..self.length 
      //{
      //  if self.buffer[i] != other.buffer[i] 
      //  {
      //    return false;
      //  }
      //}
      return CLib::c_string::strcmp(self.buffer, other.buffer) == 0;
    }
  priv:
    /** The capacity of the string. */
    let mut capacity: i32 = 10;
    /** The size of the string. */
    let mut length: i32 = 0;
    /** The buffer containing the string. */
    let buffer: StringType = "";

  priv:
    /**
     * @brief Creates a new string from a number.
     * @param[in] num The number to create the string from.
     * @param[in] format The format of the number.
     * @return The created string.
     */
    static fn [[internal_linkage, inline]] fromNumber<T>(num: T, format: char& = "%ld")
      StringView<_CharType> 
    { 
      let buffer: Self::StringType = 
        CLib::__internal::alloca_and_snprintf(10, format, num);
      return new StringView<_CharType>{buffer}; 
    }

  // Static exports
  pub:
    /**
     * @brief Constructs a string from a long integer. 
     * @param[in] num The integer to construct the string from.
     */
    static fn [[internal_linkage, inline]] from(num: i64)
      StringView<_CharType> 
    { return Self::fromNumber(num, "%ld"); }
    /**
     * @brief Constructs a string from an integer. 
     * @param[in] num The integer to construct the string from.
     */
    static fn [[internal_linkage, inline]] from(num: i32)
      StringView<_CharType> 
    { return Self::fromNumber(num, "%i"); }

    /**
      * @brief Constructs a string from a vector of characters.
      * @param[in] buffer The vector of characters to construct the string from.
      */
    static fn [[internal_linkage, inline]] from<T>(buffer: T)
      StringView<char> { return new StringView<char>{buffer}; }
}

} // namespace Core

// Type exports
type StringView<T = char> = Core::StringView<T>;
type Vector<T> = Core::Vector<T>;
type Iter<T> = Core::Iter<T>;
type Exception = Core::Exception;
type IndexError = Core::IndexError;
type String = StringView<>;
// TODO (implement wchar): using WideString as StringView<wchar&>
